'use strict';

var util = require('util');
var constant = require('./constant.cjs.js');
var fs = require('fs-extra');
var path = require('path');
var sdk = require('@module-federation/sdk');
var node_module = require('node:module');

var _documentCurrentScript = typeof document !== 'undefined' ? document.currentScript : null;
var SPLIT_CHUNK_MAP = {
    REACT: 'react',
    ROUTER: 'router',
    LODASH: 'lib-lodash',
    ANTD: 'lib-antd',
    ARCO: 'lib-arco',
    SEMI: 'lib-semi',
    AXIOS: 'lib-axios'
};
var SHARED_SPLIT_CHUNK_MAP = {
    react: SPLIT_CHUNK_MAP.REACT,
    'react-dom': SPLIT_CHUNK_MAP.REACT,
    'react-router': SPLIT_CHUNK_MAP.ROUTER,
    'react-router-dom': SPLIT_CHUNK_MAP.ROUTER,
    '@remix-run/router': SPLIT_CHUNK_MAP.ROUTER,
    lodash: SPLIT_CHUNK_MAP.LODASH,
    'lodash-es': SPLIT_CHUNK_MAP.LODASH,
    antd: SPLIT_CHUNK_MAP.ANTD,
    '@arco-design/web-react': SPLIT_CHUNK_MAP.ARCO,
    '@douyinfe/semi-ui': SPLIT_CHUNK_MAP.SEMI,
    axios: SPLIT_CHUNK_MAP.AXIOS
};
function autoDeleteSplitChunkCacheGroups(mfConfig, splitChunks) {
    if (!mfConfig.shared) {
        return;
    }
    if (!splitChunks || !(splitChunks === null || splitChunks === void 0 ? void 0 : splitChunks.cacheGroups)) {
        return;
    }
    var arrayShared = Array.isArray(mfConfig.shared) ? mfConfig.shared : Object.keys(mfConfig.shared);
    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
    try {
        for(var _iterator = arrayShared[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
            var shared = _step.value;
            var splitChunkKey = SHARED_SPLIT_CHUNK_MAP[shared];
            if (!splitChunkKey) {
                continue;
            }
            if (splitChunks.cacheGroups[splitChunkKey]) {
                delete splitChunks.cacheGroups[splitChunkKey];
            }
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally{
        try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
            }
        } finally{
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
    return splitChunks;
}

function _type_of(obj) {
    "@swc/helpers - typeof";
    return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
var addDataFetchExpose = function(exposes, key, filepath) {
    var suffix = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : '';
    if (!fs.existsSync(filepath)) {
        return false;
    }
    var dataFetchKey = key === '.' ? "./".concat(constant.DATA_FETCH_IDENTIFIER).concat(suffix) : "".concat(key, ".").concat(constant.DATA_FETCH_IDENTIFIER).concat(suffix);
    if (exposes[dataFetchKey] && exposes[dataFetchKey] !== filepath) {
        throw new Error("data fetch key ".concat(dataFetchKey, " already exists, please modify this expose key, do not end with '").concat(constant.DATA_FETCH_IDENTIFIER, "' or '").concat(constant.DATA_FETCH_CLIENT_SUFFIX, "'"));
    }
    exposes[dataFetchKey] = filepath;
    return dataFetchKey;
};
var addExcludeDtsSuffix = function(filepath) {
    return "".concat(filepath, "?exclude-mf-dts=true");
};
function addDataFetchExposes(exposes, isServer) {
    if ((typeof exposes === "undefined" ? "undefined" : _type_of(exposes)) !== 'object' || Array.isArray(exposes)) {
        return;
    }
    if (Object.keys(exposes).length === 0) {
        return;
    }
    var tempDataFetchFilepath = path.resolve(process.cwd(), "node_modules/".concat(sdk.TEMP_DIR, "/data-fetch-fallback.ts"));
    var content = "export const fetchData=()=>{throw new Error('should not be called')};";
    fs.ensureDirSync(path.dirname(tempDataFetchFilepath));
    fs.writeFileSync(tempDataFetchFilepath, content);
    Object.keys(exposes).forEach(function(key) {
        var expose = exposes[key];
        if (typeof expose !== 'string') {
            return;
        }
        var absPath = path.resolve(process.cwd(), expose);
        var dataFetchPath = "".concat(absPath.replace(path.extname(absPath), ''), ".").concat(constant.DATA_FETCH_IDENTIFIER, ".ts");
        var dataFetchClientPath = "".concat(absPath.replace(path.extname(absPath), ''), ".").concat(constant.DATA_FETCH_IDENTIFIER, ".client.ts");
        var dateFetchClientKey = addDataFetchExpose(exposes, key, dataFetchClientPath, constant.DATA_FETCH_CLIENT_SUFFIX);
        if (!isServer && dateFetchClientKey) {
            exposes[dateFetchClientKey.replace(constant.DATA_FETCH_CLIENT_SUFFIX, '')] = addExcludeDtsSuffix(tempDataFetchFilepath);
            return;
        }
        var dataFetchKey = addDataFetchExpose(exposes, key, dataFetchPath);
        if (dataFetchKey && fs.existsSync(dataFetchClientPath)) {
            exposes["".concat(dataFetchKey).concat(constant.DATA_FETCH_CLIENT_SUFFIX)] = addExcludeDtsSuffix(tempDataFetchFilepath);
        }
    });
}

function mergeStats(browserStats, nodeStats) {
    var ssrRemoteEntry = nodeStats.metaData.remoteEntry;
    browserStats.metaData.ssrRemoteEntry = ssrRemoteEntry;
    if ('publicPath' in browserStats.metaData) {
        browserStats.metaData.ssrPublicPath = nodeStats.metaData.publicPath;
    }
    return browserStats;
}
function mergeManifest(browserManifest, nodeManifest) {
    var ssrRemoteEntry = nodeManifest.metaData.remoteEntry;
    browserManifest.metaData.ssrRemoteEntry = ssrRemoteEntry;
    if ('publicPath' in browserManifest.metaData) {
        browserManifest.metaData.ssrPublicPath = nodeManifest.metaData.publicPath;
    }
    return browserManifest;
}
function mergeStatsAndManifest(nodePlugin, browserPlugin) {
    var nodeResourceInfo = nodePlugin.statsResourceInfo;
    var browserResourceInfo = browserPlugin.statsResourceInfo;
    if (!browserResourceInfo || !nodeResourceInfo || !browserResourceInfo.stats || !nodeResourceInfo.stats || !browserResourceInfo.manifest || !nodeResourceInfo.manifest) {
        throw new Error('can not get browserResourceInfo or nodeResourceInfo');
    }
    var mergedStats = mergeStats(browserResourceInfo.stats.stats, nodeResourceInfo.stats.stats);
    var mergedManifest = mergeManifest(browserResourceInfo.manifest.manifest, nodeResourceInfo.manifest.manifest);
    return {
        mergedStats: mergedStats,
        mergedStatsFilePath: browserResourceInfo.stats.filename,
        mergedManifest: mergedManifest,
        mergedManifestFilePath: browserResourceInfo.manifest.filename
    };
}
function updateStatsAndManifest(nodePlugin, browserPlugin, outputDir) {
    var _mergeStatsAndManifest = mergeStatsAndManifest(nodePlugin, browserPlugin), mergedStats = _mergeStatsAndManifest.mergedStats, mergedStatsFilePath = _mergeStatsAndManifest.mergedStatsFilePath, mergedManifest = _mergeStatsAndManifest.mergedManifest, mergedManifestFilePath = _mergeStatsAndManifest.mergedManifestFilePath;
    fs.writeFileSync(path.resolve(outputDir, mergedStatsFilePath), JSON.stringify(mergedStats, null, 2));
    fs.writeFileSync(path.resolve(outputDir, mergedManifestFilePath), JSON.stringify(mergedManifest, null, 2));
}

function _array_like_to_array(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _array_without_holes(arr) {
    if (Array.isArray(arr)) return _array_like_to_array(arr);
}
function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _iterable_to_array(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _non_iterable_spread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _object_spread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
                return Object.getOwnPropertyDescriptor(source, sym).enumerable;
            }));
        }
        ownKeys.forEach(function(key) {
            _define_property(target, key, source[key]);
        });
    }
    return target;
}
function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        keys.push.apply(keys, symbols);
    }
    return keys;
}
function _object_spread_props(target, source) {
    source = source != null ? source : {};
    if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
        ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
    }
    return target;
}
function _to_consumable_array(arr) {
    return _array_without_holes(arr) || _iterable_to_array(arr) || _unsupported_iterable_to_array(arr) || _non_iterable_spread();
}
function _unsupported_iterable_to_array(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _array_like_to_array(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);
}
var require$1 = node_module.createRequire((typeof document === 'undefined' ? require('u' + 'rl').pathToFileURL(__filename).href : (_documentCurrentScript && _documentCurrentScript.tagName.toUpperCase() === 'SCRIPT' && _documentCurrentScript.src || new URL('utils.cjs.js', document.baseURI).href)));
var resolve = require$1.resolve;
var SSR_DIR = 'ssr';
var SSR_ENV_NAME = 'mf-ssr';
function setSSREnv() {
    process.env['MF_DISABLE_EMIT_STATS'] = 'true';
    process.env['MF_SSR_PRJ'] = 'true';
}
var isDev = function() {
    return process.env['NODE_ENV'] === 'development';
};
function patchSSRRspackConfig(config, mfConfig, ssrDir, callerName) {
    var resetEntry = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : true, modifyPublicPath = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : true;
    var _config_output;
    var _config, _config1;
    (_config = config).output || (_config.output = {});
    if (modifyPublicPath) {
        var _config_output1;
        if (typeof ((_config_output1 = config.output) === null || _config_output1 === void 0 ? void 0 : _config_output1.publicPath) !== 'string') {
            throw new Error('publicPath must be string!');
        }
        var publicPath = config.output.publicPath;
        if (publicPath === 'auto') {
            throw new Error('publicPath can not be "auto"!');
        }
        var publicPathWithSSRDir = "".concat(publicPath).concat(ssrDir, "/");
        config.output.publicPath = publicPathWithSSRDir;
    }
    if (callerName === constant.CALL_NAME_MAP.RSPRESS && resetEntry) {
        config.entry = 'data:application/node;base64,';
    }
    config.target = 'async-node';
    var UniverseEntryChunkTrackerPlugin = require$1('@module-federation/node/universe-entry-chunk-tracker-plugin').default;
    (_config1 = config).plugins || (_config1.plugins = []);
    isDev() && config.plugins.push(new UniverseEntryChunkTrackerPlugin());
    var uniqueName = mfConfig.name || ((_config_output = config.output) === null || _config_output === void 0 ? void 0 : _config_output.uniqueName);
    var chunkFileName = config.output.chunkFilename;
    if (typeof chunkFileName === 'string' && uniqueName && !chunkFileName.includes(uniqueName)) {
        var suffix = "".concat(sdk.encodeName(uniqueName), "-[contenthash].js");
        config.output.chunkFilename = chunkFileName.replace('.js', suffix);
    }
    return config;
}
function createSSRREnvConfig(envConfig, mfConfig, ssrDir, rsbuildConfig, callerName) {
    var _ssrEnvConfig_output, _ssrEnvConfig_output_distPath, _ssrEnvConfig_output1, _rsbuildConfig_output_distPath, _rsbuildConfig_output;
    var ssrEnvConfig = _object_spread_props(_object_spread({}, envConfig), {
        tools: {
            rspack: function(config, param) {
                var environment = param.environment;
                if (environment.name !== SSR_ENV_NAME) {
                    return;
                }
                patchSSRRspackConfig(config, mfConfig, ssrDir, callerName);
            }
        }
    });
    ssrEnvConfig.output = _object_spread_props(_object_spread({}, ssrEnvConfig.output), {
        target: 'node',
        distPath: _object_spread_props(_object_spread({}, (_ssrEnvConfig_output = ssrEnvConfig.output) === null || _ssrEnvConfig_output === void 0 ? void 0 : _ssrEnvConfig_output.distPath), {
            root: path.join(((_ssrEnvConfig_output1 = ssrEnvConfig.output) === null || _ssrEnvConfig_output1 === void 0 ? void 0 : (_ssrEnvConfig_output_distPath = _ssrEnvConfig_output1.distPath) === null || _ssrEnvConfig_output_distPath === void 0 ? void 0 : _ssrEnvConfig_output_distPath.root) || ((_rsbuildConfig_output = rsbuildConfig.output) === null || _rsbuildConfig_output === void 0 ? void 0 : (_rsbuildConfig_output_distPath = _rsbuildConfig_output.distPath) === null || _rsbuildConfig_output_distPath === void 0 ? void 0 : _rsbuildConfig_output_distPath.root) || '', ssrDir)
        }),
        emitAssets: true
    });
    return ssrEnvConfig;
}
function createSSRMFConfig(mfConfig) {
    var _mfConfig_library;
    var _mfConfig_library_type;
    var ssrMFConfig = _object_spread_props(_object_spread({}, mfConfig), {
        exposes: _object_spread({}, mfConfig.exposes),
        library: _object_spread_props(_object_spread({}, mfConfig.library), {
            name: mfConfig.name,
            type: (_mfConfig_library_type = (_mfConfig_library = mfConfig.library) === null || _mfConfig_library === void 0 ? void 0 : _mfConfig_library.type) !== null && _mfConfig_library_type !== void 0 ? _mfConfig_library_type : 'commonjs-module'
        }),
        dts: false,
        dev: false,
        runtimePlugins: _to_consumable_array(mfConfig.runtimePlugins || [])
    });
    ssrMFConfig.runtimePlugins.push(resolve('@module-federation/node/runtimePlugin'));
    if (isDev()) {
        ssrMFConfig.runtimePlugins.push(resolve('@module-federation/node/record-dynamic-remote-entry-hash-plugin'));
    }
    return ssrMFConfig;
}

function isRegExp(target) {
    return util.types.isRegExp(target);
}

exports.DEFAULT_ASSET_PREFIX = constant.DEFAULT_ASSET_PREFIX;
exports.SSR_DIR = SSR_DIR;
exports.SSR_ENV_NAME = SSR_ENV_NAME;
exports.addDataFetchExposes = addDataFetchExposes;
exports.autoDeleteSplitChunkCacheGroups = autoDeleteSplitChunkCacheGroups;
exports.createSSRMFConfig = createSSRMFConfig;
exports.createSSRREnvConfig = createSSRREnvConfig;
exports.isRegExp = isRegExp;
exports.patchSSRRspackConfig = patchSSRRspackConfig;
exports.setSSREnv = setSSREnv;
exports.updateStatsAndManifest = updateStatsAndManifest;
//# sourceMappingURL=utils.cjs.js.map
