'use strict';

var commander = require('commander');
var dtsPlugin = require('@module-federation/dts-plugin');
var sdk = require('@module-federation/sdk');
var chalk = require('chalk');
var path = require('path');
var nodeBundleRequire = require('@modern-js/node-bundle-require');
var url = require('url');

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */ /* global Reflect, Promise, SuppressedError, Symbol, Iterator */ function _instanceof(left, right) {
    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
        return !!right[Symbol.hasInstance](left);
    } else {
        return left instanceof right;
    }
}
function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return _instanceof(value, P) ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}
typeof SuppressedError === "function" ? SuppressedError : function _SuppressedError(error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

var applyCommonOptions = function(command) {
    command.option('-c --config <config>', 'specify the configuration file, can be a relative or absolute path');
    command.option('-m --mode <mode>', 'Specify the runtime environment. You can choose "dev" or "prod". The default value is "dev". After setting, the process.env.NODE_ENV environment variable will be automatically injected with "development" or "production" according to the value.', function(value) {
        var validChoices = {
            dev: 'development',
            prod: 'production'
        };
        if (!Object.keys(validChoices).includes(value)) {
            throw new Error("Invalid mode: ".concat(value, ". Valid choices are: ").concat(Object.keys(validChoices).join(', ')));
        }
        var targetEnv = validChoices[value];
        if (process.env.NODE_ENV !== targetEnv) {
            console.log("process.env.NODE_ENV is set to ".concat(targetEnv));
        }
        process.env.NODE_ENV = targetEnv;
        return value;
    }, 'dev');
};

function _tagged_template_literal(strings, raw) {
    if (!raw) {
        raw = strings.slice(0);
    }
    return Object.freeze(Object.defineProperties(strings, {
        raw: {
            value: Object.freeze(raw)
        }
    }));
}
function _templateObject() {
    var data = _tagged_template_literal([
        "{bold {cyan ",
        "}}"
    ]);
    _templateObject = function _templateObject() {
        return data;
    };
    return data;
}
var PREFIX = '[ Module Federation CLI ]';
var logger = sdk.createLogger(chalk(_templateObject(), PREFIX));

function _ts_generator$2(thisArg, body) {
    var f, y, t, g, _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    };
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(_)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
}
function dts(options_1, _a) {
    return __awaiter(this, arguments, void 0, function(options, param) {
        var readConfig, _options_fetch, fetch, _options_generate, generate, _options_root, root, output, config, mfConfig, normalizedDtsOptions, dtsManagerOptions, dtsManagerOptions1;
        return _ts_generator$2(this, function(_state) {
            switch(_state.label){
                case 0:
                    readConfig = param.readConfig;
                    _options_fetch = options.fetch, fetch = _options_fetch === void 0 ? true : _options_fetch, _options_generate = options.generate, generate = _options_generate === void 0 ? true : _options_generate, _options_root = options.root, root = _options_root === void 0 ? process.cwd() : _options_root, output = options.output, config = options.config;
                    return [
                        4,
                        readConfig(config)
                    ];
                case 1:
                    mfConfig = _state.sent();
                    if (!dtsPlugin.isTSProject(mfConfig.dts, root)) {
                        logger.error('dts is only supported for TypeScript projects');
                        return [
                            2
                        ];
                    }
                    normalizedDtsOptions = dtsPlugin.normalizeDtsOptions(mfConfig, root, {
                        defaultGenerateOptions: {
                            generateAPITypes: true,
                            compileInChildProcess: false,
                            abortOnError: true,
                            extractThirdParty: false,
                            extractRemoteTypes: false
                        },
                        defaultConsumeOptions: {
                            abortOnError: true,
                            consumeAPITypes: true
                        }
                    });
                    if (!normalizedDtsOptions) {
                        logger.error('dts is not enabled in module-federation.config.ts');
                        return [
                            2
                        ];
                    }
                    if (!fetch) return [
                        3,
                        4
                    ];
                    dtsManagerOptions = dtsPlugin.normalizeConsumeTypesOptions({
                        context: root,
                        dtsOptions: normalizedDtsOptions,
                        pluginOptions: mfConfig
                    });
                    if (!!dtsManagerOptions) return [
                        3,
                        2
                    ];
                    logger.warn('dts.consumeTypes is not enabled in module-federation.config.ts, skip fetching remote types');
                    return [
                        3,
                        4
                    ];
                case 2:
                    logger.debug('start fetching remote types...');
                    return [
                        4,
                        dtsPlugin.consumeTypesAPI(dtsManagerOptions)
                    ];
                case 3:
                    _state.sent();
                    logger.debug('fetch remote types success!');
                    _state.label = 4;
                case 4:
                    if (!generate) return [
                        3,
                        6
                    ];
                    dtsManagerOptions1 = dtsPlugin.normalizeGenerateTypesOptions({
                        context: root,
                        outputDir: output,
                        dtsOptions: normalizedDtsOptions,
                        pluginOptions: mfConfig
                    });
                    if (!dtsManagerOptions1) {
                        logger.warn('dts.generateTypes is not enabled in module-federation.config.ts, skip generating types');
                        return [
                            2
                        ];
                    }
                    logger.debug('start generating types...');
                    return [
                        4,
                        dtsPlugin.generateTypesAPI({
                            dtsManagerOptions: dtsManagerOptions1
                        })
                    ];
                case 5:
                    _state.sent();
                    logger.debug('generate types success!');
                    _state.label = 6;
                case 6:
                    return [
                        2
                    ];
            }
        });
    });
}

function prepareCli(param) {
    var welcomeMsg = param.welcomeMsg;
    if (!process.env.NODE_ENV) {
        process.env.NODE_ENV = 'development';
    }
    var npm_execpath = process.env.npm_execpath;
    if (!npm_execpath || npm_execpath.includes('npx-cli.js') || npm_execpath.includes('.bun')) {
        console.log();
    }
    logger.info(welcomeMsg);
}

function _ts_generator$1(thisArg, body) {
    var f, y, t, g, _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    };
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(_)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
}
var DEFAULT_CONFIG_PATH = 'module-federation.config.ts';
var getConfigPath = function(userConfigPath) {
    var defaultPath = path.resolve(process.cwd(), DEFAULT_CONFIG_PATH);
    var filepath = userConfigPath !== null && userConfigPath !== void 0 ? userConfigPath : defaultPath;
    return path.isAbsolute(filepath) ? filepath : path.resolve(process.cwd(), filepath);
};
function readConfig(userConfigPath) {
    return __awaiter(this, void 0, void 0, function() {
        var configPath, preBundlePath, mfConfig;
        return _ts_generator$1(this, function(_state) {
            switch(_state.label){
                case 0:
                    configPath = getConfigPath(userConfigPath);
                    return [
                        4,
                        nodeBundleRequire.bundle(configPath)
                    ];
                case 1:
                    preBundlePath = _state.sent();
                    return [
                        4,
                        import(url.pathToFileURL(preBundlePath).href)
                    ];
                case 2:
                    mfConfig = _state.sent().default.default;
                    return [
                        2,
                        mfConfig
                    ];
            }
        });
    });
}

function _ts_generator(thisArg, body) {
    var f, y, t, g, _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    };
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(_)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
}
function cli(cliOptions) {
    var _this = this;
    var name = cliOptions.name, version = cliOptions.version, applyCommands = cliOptions.applyCommands;
    commander.program.name(name).usage('<command> [options]').version(version);
    var dtsCommand = commander.program.command('dts');
    dtsCommand.option('--root <root>', 'specify the project root directory').option('--output <output>', 'specify the generated dts output directory').option('--fetch <boolean>', 'fetch types from remote, default is true', function(value) {
        return value === 'true';
    }, true).option('--generate <boolean>', 'generate types, default is true', function(value) {
        return value === 'true';
    }, true);
    applyCommonOptions(dtsCommand);
    dtsCommand.description('generate or fetch the mf types').action(function(options) {
        return __awaiter(_this, void 0, void 0, function() {
            var err;
            return _ts_generator(this, function(_state) {
                switch(_state.label){
                    case 0:
                        _state.trys.push([
                            0,
                            2,
                            ,
                            3
                        ]);
                        return [
                            4,
                            dts(options, cliOptions)
                        ];
                    case 1:
                        _state.sent();
                        return [
                            3,
                            3
                        ];
                    case 2:
                        err = _state.sent();
                        console.error(err);
                        process.exit(1);
                        return [
                            3,
                            3
                        ];
                    case 3:
                        return [
                            2
                        ];
                }
            });
        });
    });
    if (typeof applyCommands === 'function') {
        applyCommands(commander.program, applyCommonOptions);
    }
    commander.program.parse();
}
function runCli(options) {
    var normalizedOptions = Object.assign({
        loggerPrefix: PREFIX,
        welcomeMsg: "".concat("Module Federation v".concat("0.19.1"), "\n"),
        name: 'mf',
        readConfig: readConfig,
        version: "0.19.1",
        applyCommands: function() {}
    }, options);
    logger.setPrefix(normalizedOptions.loggerPrefix);
    prepareCli(normalizedOptions);
    try {
        cli(normalizedOptions);
    } catch (err) {
        console.error(err);
    }
}

exports.runCli = runCli;
//# sourceMappingURL=index.cjs.js.map
